<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ruleta Casino PRO</title>

<link rel="apple-touch-icon" sizes="1024x1024" href="icono.png">

<style>
body{
    margin:0;
    font-family:Arial, sans-serif;
    text-align:center;
    background: radial-gradient(circle at top,#1b2a49,#0f172a);
    color:white;
}

h1{margin-top:20px;}

input{
    padding:10px;
    margin:5px;
    border-radius:8px;
    border:none;
    width:200px;
}

button{
    padding:10px 20px;
    margin:10px;
    border:none;
    border-radius:8px;
    font-weight:bold;
    cursor:pointer;
}

#agregar{background:#16a34a;color:white;}
#iniciar{background:#facc15;}
#limpiar{background:#dc2626;color:white;}

/* Contenedor para poner puntero fijo encima del canvas */
.ruleta-wrapper{
    position: relative;
    width: 350px;
    height: 350px;
    margin: 20px auto 0;
}

canvas{
    background:white;
    border-radius:50%;
}

/* Puntero fijo (flecha) centrado arriba, apuntando hacia abajo */
.puntero{
    position: absolute;
    top: -6px;                   /* leve superposici√≥n al borde */
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 14px solid transparent;
    border-right: 14px solid transparent;
    border-bottom: 22px solid #ef4444; /* color de la flecha */
    filter: drop-shadow(0 2px 2px rgba(0,0,0,.5));
    z-index: 2;
}

#resultado{
    font-size:22px;
    margin-top:20px;
    font-weight:bold;
}
</style>
</head>
<body>

<h1>üé∞ Ruleta Casino PRO</h1>

<input id="nombre" placeholder="Nombre">
<input id="numero" placeholder="N√∫mero" type="number">
<button id="agregar">Agregar</button>

<div>
<button id="iniciar">Iniciar Ruleta</button>
<button id="limpiar">Limpiar Lista</button>
</div>

<!-- Envolvemos el canvas con un contenedor para poner el puntero encima -->
<div class="ruleta-wrapper">
  <div class="puntero" aria-hidden="true"></div>
  <canvas id="ruleta" width="350" height="350"></canvas>
</div>

<div id="resultado"></div>

<script>
let lista = JSON.parse(localStorage.getItem("lista_ruleta")) || [];
const canvas = document.getElementById("ruleta");
const ctx = canvas.getContext("2d");
let girando=false;
let anguloActual=0;              // rotaci√≥n acumulada de la ruleta
let indiceSeleccionado = -1;     // para resaltar el ganador

const CX = 175, CY = 175, R = 170;         // centro y radio
const TEXT_R = R - 35;                     // ‚¨ÖÔ∏è NUEVO: texto m√°s cerca del borde/flecha
const PUNTERO_ANG = -Math.PI/2;            // ‚¨ÖÔ∏è Flecha fija hacia arriba

/* ========= Audio "tic" ========== */
let audioCtx = null;                       // ‚¨ÖÔ∏è NUEVO
function initAudio(){                      // ‚¨ÖÔ∏è NUEVO
  if (!audioCtx) {
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playTick(){                        // ‚¨ÖÔ∏è NUEVO (clic corto, con leve variaci√≥n)
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  const base = 1550;
  const jitter = (Math.random()*220) - 110; // ¬±110 Hz
  osc.frequency.value = base + jitter;
  osc.type = 'square';

  // Envoltura r√°pida (ataque corto, decaimiento veloz)
  gain.gain.setValueAtTime(0.0, t);
  gain.gain.linearRampToValueAtTime(0.14, t + 0.006);
  gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);

  osc.connect(gain).connect(audioCtx.destination);
  osc.start(t);
  osc.stop(t + 0.07);
}
/* ================================= */

function guardar(){
    localStorage.setItem("lista_ruleta",JSON.stringify(lista));
}

function dibujar(){
    ctx.clearRect(0,0,350,350);

    if(lista.length===0){
        return;
    }

    const angulo = 2*Math.PI/lista.length;

    for(let i=0;i<lista.length;i++){
        // Sector
        ctx.beginPath();
        ctx.moveTo(CX,CY);
        ctx.arc(CX,CY,R,i*angulo,(i+1)*angulo);
        ctx.fillStyle = `hsl(${i*360/lista.length},70%,50%)`;
        ctx.fill();

        // Texto (centrado angularmente, m√°s cerca del borde)
        ctx.save();
        ctx.translate(CX,CY);
        ctx.rotate(i*angulo + angulo/2);
        ctx.fillStyle="white";
        ctx.font="14px Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        // Limitar ancho del texto al arco disponible aproximado
        const maxTextWidth = (angulo * (TEXT_R)); // aprox
        ctx.shadowColor = "rgba(0,0,0,0.4)";      // ligera sombra para legibilidad
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.fillText(lista[i].nombre, TEXT_R, 0, Math.max(60, maxTextWidth));
        ctx.restore();

        // Resalte del seleccionado
        if (i === indiceSeleccionado) {
            ctx.save();
            ctx.lineWidth = 6;
            ctx.strokeStyle = "#ffffffcc";
            ctx.beginPath();
            ctx.arc(CX, CY, R-3, i*angulo, (i+1)*angulo);
            ctx.stroke();

            ctx.lineWidth = 6;
            ctx.strokeStyle = "#fde047"; // amarillo
            ctx.beginPath();
            ctx.arc(CX, CY, R-12, i*angulo, (i+1)*angulo);
            ctx.stroke();
            ctx.restore();
        }
    }

    // Borde exterior
    ctx.beginPath();
    ctx.lineWidth = 4;
    ctx.strokeStyle = "#0f172a";
    ctx.arc(CX, CY, R, 0, 2*Math.PI);
    ctx.stroke();
}

// Dibujo inicial con la rotaci√≥n actual
redibujarConRotacion();

document.getElementById("agregar").onclick=function(){
    const nombre=document.getElementById("nombre").value.trim();
    const numero=document.getElementById("numero").value.trim();
    if(!nombre || !numero) return alert("Completa los datos");

    if(lista.some(x=>x.numero==numero)){
        alert("Ese n√∫mero ya fue agregado");
        return;
    }

    lista.push({nombre,numero});
    guardar();
    redibujarConRotacion();
    document.getElementById("nombre").value="";
    document.getElementById("numero").value="";
};

document.getElementById("limpiar").onclick=function(){
    lista=[];
    guardar();
    indiceSeleccionado=-1;
    anguloActual=0;
    redibujarConRotacion();
    document.getElementById("resultado").innerText="";
};

function hablar(texto){
    const msg=new SpeechSynthesisUtterance(texto);
    msg.lang="es-MX";
    msg.rate=0.9;
    speechSynthesis.cancel();
    speechSynthesis.speak(msg);
}

// Redibuja respetando la rotaci√≥n actual del canvas
function redibujarConRotacion(){
    ctx.save();
    ctx.clearRect(0,0,350,350);
    ctx.translate(CX,CY);
    ctx.rotate(anguloActual);
    ctx.translate(-CX,-CY);
    dibujar();
    ctx.restore();
}

/**
 * Easing functions (para variar la "sensaci√≥n" del giro)
 */
const easings = {
  easeOutCubic: t => 1 - Math.pow(1 - t, 3),
  easeOutQuint: t => 1 - Math.pow(1 - t, 5),
  easeOutExpo:  t => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t)),
  easeOutBack:  t => {
      const s = 1.70158;
      const inv = t - 1;
      return 1 + (s + 1)*Math.pow(inv,3) + s*Math.pow(inv,2);
  }
};

/**
 * Gira la ruleta y deja el centro del segmento 'index' justo bajo el puntero fijo,
 * que est√° apuntando hacia arriba (√°ngulo -PI/2).
 * - Vueltas, duraci√≥n, direcci√≥n y easing aleatorios en cada giro.
 * - Genera "tic" cada vez que el puntero cruza una separaci√≥n de sector.
 */
function girarYSeleccionar(index, callback){
    if (girando) return;
    girando = true;

    const n = lista.length;
    const anguloSeg = 2*Math.PI/n;
    const dosPI = 2*Math.PI;

    // √Ångulo actual normalizado (por si venimos de un giro previo)
    const anguloInicio = ((anguloActual % dosPI) + dosPI) % dosPI;

    // Centro del segmento objetivo
    const anguloCentroSegmento = index*anguloSeg + anguloSeg/2;

    // Queremos que (anguloCentroSegmento + anguloFinal) ‚â° PUNTERO_ANG  (mod 2œÄ)
    // Desde anguloInicio, deltaNorm m√≠nimo positivo:
    let deltaNorm = (PUNTERO_ANG - anguloCentroSegmento - anguloInicio) % dosPI;
    deltaNorm = (deltaNorm + dosPI) % dosPI;

    // Aleatoriedades del giro
    const vueltas = Math.floor(5 + Math.random()*6);            // 5..10 vueltas
    const duracion = 2200 + Math.random()*2200;                 // 2200..4400 ms
    const dir = Math.random() < 0.5 ? 1 : -1;                   // horario/antihorario
    const easingNames = Object.keys(easings);
    const easing = easings[easingNames[Math.floor(Math.random()*easingNames.length)]];

    // Si vamos en sentido positivo: sumamos deltaNorm
    // Si vamos en sentido negativo: desplazamos hacia atr√°s lo equivalente
    const deltaAtras = (dosPI - deltaNorm) % dosPI;
    const deltaTotal = dir === 1
        ? vueltas*dosPI + deltaNorm
        : - (vueltas*dosPI + deltaAtras);

    // ---- Control de "tic" por cruce de separaciones ----
    // k = √≠ndice de sector cuyo LIMITE est√° bajo el puntero (0..n-1).
    // Usamos 'rel' = (PUNTERO_ANG - theta) mod 2œÄ y k = floor(rel/anguloSeg)
    let prevK = null;
    function actualizarTic(theta){
        const rel = ((PUNTERO_ANG - theta) % dosPI + dosPI) % dosPI;
        const k = Math.floor(rel / anguloSeg);
        if (prevK === null){
            prevK = k;
            return;
        }
        if (k !== prevK){
            // Podr√≠amos reproducir m√∫ltiples tics si se saltan separaciones,
            // pero a 60fps normalmente cambia de 1 en 1.
            playTick();
            prevK = k;
        }
    }
    // -----------------------------------------------------

    // Aseguramos que el AudioContext est√© activo (necesita interacci√≥n del usuario)
    initAudio();

    const inicio = performance.now();
    function animar(tiempo){
        let p = (tiempo - inicio) / duracion;
        if (p > 1) p = 1;

        const e = easing(p);
        const theta = anguloInicio + deltaTotal * e;
        anguloActual = theta;

        // Actualizar "tic" en funci√≥n del √°ngulo actual
        actualizarTic(((theta % dosPI)+dosPI)%dosPI);

        redibujarConRotacion();

        if (p < 1){
            requestAnimationFrame(animar);
        }else{
            // Aterrizar exacto
            const anguloFinal = anguloInicio + deltaTotal;
            anguloActual = ((anguloFinal % dosPI) + dosPI) % dosPI;

            indiceSeleccionado = index; // resalte
            redibujarConRotacion();

            girando = false;
            callback(index);
        }
    }

    requestAnimationFrame(animar);
}

document.getElementById("iniciar").onclick=async function(){
    if(lista.length < 3){
        alert("Necesitas m√≠nimo 3 participantes");
        return;
    }

    initAudio(); // asegura audio listo al primer clic

    let copia=[...lista];

    for(let i=0;i<3;i++){
        await new Promise(resolve=>{
            // √çndice aleatorio sobre la lista "copia"
            const index = Math.floor(Math.random()*copia.length);
            girarYSeleccionar(index, seleccionado=>{
                const elegido=copia[seleccionado];
                if(i<2){
                    document.getElementById("resultado").innerText=elegido.nombre+" - FUERA ‚ùå";
                    hablar(elegido.nombre+" fuera");
                    // Eliminamos y limpiamos resalte para la siguiente ronda
                    copia.splice(seleccionado,1);
                    indiceSeleccionado = -1;
                }else{
                    document.getElementById("resultado").innerText="üèÜ "+elegido.nombre+" GANADOR üéâ";
                    hablar(elegido.nombre+" ganador");
                    lanzarConfeti();
                    // Dejamos resalte del ganador visible
                }
                resolve();
            });
        });

        if(i<2){
            // Persistimos la lista reducida
            lista=copia;
            guardar();

            // No reseteamos anguloActual para que cada giro inicie distinto
            redibujarConRotacion();

            await new Promise(r=>setTimeout(r,1200));
        }
    }
};

function lanzarConfeti(){
    for(let i=0;i<200;i++){
        const div=document.createElement("div");
        div.style.position="fixed";
        div.style.width="6px";
        div.style.height="6px";
        div.style.background=`hsl(${Math.random()*360},100%,50%)`;
        div.style.left=Math.random()*100+"vw";
        div.style.top="-10px";
        div.style.zIndex=9999;
        document.body.appendChild(div);

        const anim=div.animate([
            {transform:"translateY(0)"},
            {transform:"translateY(100vh)"}
        ],{
            duration:2000+Math.random()*2000,
            easing:"linear"
        });

        anim.onfinish=()=>div.remove();
    }
}
</script>

</body>
</html>
