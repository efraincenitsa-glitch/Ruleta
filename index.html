<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Ruleta Casino PRO</title>

<!-- Icono opcional para iOS -->
<link rel="apple-touch-icon" sizes="1024x1024" href="icono.png">

<style>
  body{
      margin:0;
      font-family:Arial, sans-serif;
      text-align:center;
      background: radial-gradient(circle at top,#1b2a49,#0f172a);
      color:white;
  }

  h1{margin-top:20px;}

  input{
      padding:10px;
      margin:5px;
      border-radius:8px;
      border:none;
      width:200px;
  }

  button{
      padding:10px 20px;
      margin:10px;
      border:none;
      border-radius:8px;
      font-weight:bold;
      cursor:pointer;
  }

  #agregar{background:#16a34a;color:white;}
  #iniciar{background:#facc15;}
  #limpiar{background:#dc2626;color:white;}

  #resultado{
      font-size:32px;
      margin-top:20px;
      font-weight:bold;
      min-height:40px;
  }

  .ruleta-wrapper{
      position: relative;
      width: 360px;
      height: 360px;
      margin: 20px auto 0;
  }

  canvas{
      background:white;
      border-radius:50%;
      box-shadow:0 0 20px #000;
  }

  .puntero{
      position:absolute;
      top:-6px;
      left:50%;
      transform:translateX(-50%);
      width:0;height:0;
      border-left:14px solid transparent;
      border-right:14px solid transparent;
      border-bottom:22px solid #ef4444;
      z-index:2;
  }

  /* LED giratorio decorativo */
  .ruleta-wrapper::before{
      content:"";
      position:absolute;
      inset:-12px;
      border-radius:50%;
      background:conic-gradient(
          red, yellow, lime, cyan, blue, magenta, red
      );
      animation:led 2s linear infinite;
      z-index:-1;
  }

  @keyframes led{
      from{transform:rotate(0deg);}
      to{transform:rotate(360deg);}
  }

  /* Pantalla ganador gigante */
  #pantallaGanador{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.9);
      display:none;
      align-items:center;
      justify-content:center;
      font-size:64px;
      font-weight:bold;
      color:#fde047;
      text-align:center;
      z-index:999;
  }
</style>

<!-- Librer√≠a de confeti -->
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
</head>
<body>

<h1>üé∞ Ruleta Casino PRO</h1>

<input id="nombre" placeholder="Nombre" />
<input id="numero" placeholder="N√∫mero" type="number" />
<button id="agregar">Agregar</button>

<div>
  <button id="iniciar">Iniciar Ruleta</button>
  <button id="limpiar">Limpiar Lista</button>
</div>

<div class="ruleta-wrapper">
  <div class="puntero"></div>
  <canvas id="ruleta" width="360" height="360"></canvas>
</div>

<div id="resultado"></div>

<div id="pantallaGanador"></div>

<script>
/* ====== REFERENCIAS A ELEMENTOS ====== */
const canvas = document.getElementById("ruleta");
const ctx = canvas.getContext("2d");
const nombreInput = document.getElementById("nombre");
const numeroInput = document.getElementById("numero");
const agregar = document.getElementById("agregar");
const iniciar = document.getElementById("iniciar");
const limpiar = document.getElementById("limpiar");
const resultado = document.getElementById("resultado");
const pantallaGanador = document.getElementById("pantallaGanador");

/* ====== ESTADO ====== */
let lista = JSON.parse(localStorage.getItem("lista_ruleta")) || [];
let girando = false;
let anguloActual = 0;     // Rotaci√≥n acumulada de la ruleta
let indiceSeleccionado = -1;

// Opacidades paralelas a la lista (1 = visible, 0 = invisible)
let opacidades = lista.map(() => 1);

const CX=180, CY=180, R=170;
const PUNTERO_ANG=-Math.PI/2; // El puntero mira hacia arriba

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

/* ===== VOZ CASINO ===== */
function hablar(texto, velocidad=0.9, tono=1){
  try{
    const msg=new SpeechSynthesisUtterance(texto);
    msg.lang="es-MX";
    msg.rate=velocidad;
    msg.pitch=tono;
    // Cancelar cualquier cola previa para evitar solapamientos
    speechSynthesis.cancel();
    speechSynthesis.speak(msg);
  }catch(e){
    // Falla silenciosamente si el navegador no soporta TTS
    console.warn("TTS no disponible:", e);
  }
}

/* ===== N√∫mero en d√≠gitos para mejor dicci√≥n TTS ===== */
function numeroEnDigitos(n) {
  return String(n).split("").join(" ");
}

function guardar(){
  localStorage.setItem("lista_ruleta", JSON.stringify(lista));
}

/* ===== DIBUJAR (usa opacidades por segmento) ===== */
function dibujar(){
  ctx.clearRect(0,0,360,360);
  if(lista.length===0) return;

  const ang=2*Math.PI/lista.length;

  for(let i=0;i<lista.length;i++){
    const alpha = (opacidades[i] ?? 1);

    ctx.save();
    ctx.globalAlpha = alpha;

    ctx.beginPath();
    ctx.moveTo(CX,CY);
    ctx.arc(CX,CY,R, i*ang, (i+1)*ang);
    ctx.fillStyle=`hsl(${i*360/lista.length},70%,50%)`;
    ctx.fill();

    // Etiqueta
    ctx.translate(CX,CY);
    ctx.rotate(i*ang + ang/2);
    ctx.fillStyle="white";
    ctx.textAlign="center";
    ctx.font="16px Arial";
    ctx.fillText(lista[i].nombre, R-60, 0);

    ctx.restore();
  }

  // Asegura alpha normal para lo dem√°s
  ctx.globalAlpha = 1;
}

function redibujar(){
  ctx.save();
  ctx.clearRect(0,0,360,360);
  ctx.translate(CX,CY);
  ctx.rotate(anguloActual);
  ctx.translate(-CX,-CY);
  dibujar();
  ctx.restore();
}

// Inicial
redibujar();

/* ===== AGREGAR ===== */
agregar.onclick=function(){
  const nombre = nombreInput.value.trim();
  const numero = numeroInput.value.trim();
  if(!nombre || !numero) return alert("Completa los datos");

  if(lista.some(x => x.numero == numero))
    return alert("N√∫mero duplicado");

  lista.push({ nombre, numero });
  opacidades.push(1);     // opacidad para el nuevo segmento
  guardar();
  redibujar();

  nombreInput.value = "";
  numeroInput.value = "";
};

/* ===== LIMPIAR ===== */
limpiar.onclick=function(){
  if(!confirm("¬øSeguro que deseas borrar toda la lista?")) return;
  lista=[];
  opacidades=[];
  guardar();
  indiceSeleccionado=-1;
  anguloActual=0;
  redibujar();
  resultado.innerText="";
};

/* ===== ANIMACI√ìN DE DESVANECIMIENTO ===== */
function animarDesvanecer(index, dur=600){
  return new Promise(resolve=>{
    const t0 = performance.now();
    function frame(t){
      const p = Math.min(1, (t - t0) / dur);
      // 1 ‚Üí 0
      opacidades[index] = 1 - p;
      redibujar();
      if(p < 1){
        requestAnimationFrame(frame);
      }else{
        resolve();
      }
    }
    requestAnimationFrame(frame);
  });
}

/* ===== GIRAR (ajustado para caer EXACTO en el segmento) ===== */
function girar(index){
  return new Promise(resolve=>{
    const n = lista.length;
    const angSeg = 2*Math.PI/n;
    const centro = index*angSeg + angSeg/2;      // centro del segmento elegido (en sistema sin rotaci√≥n)
    const objetivoBase = PUNTERO_ANG - centro;   // √°ngulo que al aplicar deja el centro bajo el puntero

    const dosPI = 2*Math.PI;
    const inicio = anguloActual;

    // Diferencia normalizada entre el objetivo y la rotaci√≥n actual
    let diff = (objetivoBase - (inicio % dosPI));
    diff = (diff % dosPI + dosPI) % dosPI;       // [0, 2œÄ)

    const vueltas = 6;        // vueltas extra
    const dur = 3000;         // ms
    const final = inicio + vueltas*dosPI + diff;

    const t0 = performance.now();
    function easeOutCubic(p){ return 1 - Math.pow(1-p,3); }

    function frame(t){
      let p = Math.min(1, (t - t0) / dur);
      const eased = easeOutCubic(p);

      anguloActual = inicio + (final - inicio)*eased;
      redibujar();

      if(p < 1){
        requestAnimationFrame(frame);
      }else{
        // Normaliza para no acumular infinitamente
        anguloActual = ((final % dosPI) + dosPI) % dosPI;
        redibujar();
        resolve();
      }
    }
    requestAnimationFrame(frame);
  });
}

/* ===== Confeti para el ganador ===== */
function confetiGanador() {
  // Si la librer√≠a no est√° disponible, salir sin romper nada
  if (typeof window.confetti !== "function") return;

  // Estallido inicial
  window.confetti({
    particleCount: 140,
    spread: 80,
    startVelocity: 45,
    scalar: 1,
    origin: { y: 0.6 },
    zIndex: 10000   // por encima de #pantallaGanador (z-index: 999)
  });

  // Lluvia breve desde ambos lados por ~2.5s
  const duration = 2500;
  const animationEnd = Date.now() + duration;
  const defaults = { startVelocity: 35, spread: 70, ticks: 90, zIndex: 10000 };

  function randomInRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  const interval = setInterval(function() {
    const timeLeft = animationEnd - Date.now();
    if (timeLeft <= 0) {
      clearInterval(interval);
      return;
    }
    const particleCount = Math.max(20, 60 * (timeLeft / duration));
    // Izquierda
    window.confetti(Object.assign({}, defaults, {
      particleCount,
      origin: { x: randomInRange(0.1, 0.3), y: randomInRange(0.1, 0.3) }
    }));
    // Derecha
    window.confetti(Object.assign({}, defaults, {
      particleCount,
      origin: { x: randomInRange(0.7, 0.9), y: randomInRange(0.1, 0.3) }
    }));
  }, 250);
}

/* ===== FANFARRIA (Web Audio API, sin archivos) ===== */
let audioCtx = null;
function ensureAudioContext() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === "suspended") {
    audioCtx.resume();
  }
}

function playTone(freq, startTime, duration, type = "sawtooth", volume = 0.2) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, startTime);

  // Envolvente (ADSR simple)
  const attack = 0.02, decay = 0.10, sustain = 0.7, release = 0.12;
  gain.gain.setValueAtTime(0, startTime);
  gain.gain.linearRampToValueAtTime(volume, startTime + attack);
  gain.gain.linearRampToValueAtTime(volume * sustain, startTime + attack + decay);
  gain.gain.setValueAtTime(volume * sustain, startTime + duration - release);
  gain.gain.linearRampToValueAtTime(0.0001, startTime + duration);

  osc.connect(gain).connect(audioCtx.destination);
  osc.start(startTime);
  osc.stop(startTime + duration + 0.02);
}

function playFanfare() {
  try {
    ensureAudioContext();
    const now = audioCtx.currentTime;

    // Secuencia de notas (C5, E5, G5, C6) y acorde final
    const C5 = 523.25, E5 = 659.25, G5 = 783.99, C6 = 1046.5;

    // Trompeta principal (sawtooth con leve vibrato)
    const noteDur = 0.18;
    const gap = 0.05;

    playTone(C5, now + 0*(noteDur+gap), noteDur, "sawtooth", 0.22);
    playTone(E5, now + 1*(noteDur+gap), noteDur, "sawtooth", 0.22);
    playTone(G5, now + 2*(noteDur+gap), noteDur, "sawtooth", 0.22);
    playTone(C6, now + 3*(noteDur+gap), noteDur, "sawtooth", 0.22);

    // Acorde final m√°s largo
    const chordStart = now + 4*(noteDur+gap) + 0.02;
    const chordDur = 0.7;
    playTone(C5, chordStart, chordDur, "sawtooth", 0.25);
    playTone(E5, chordStart, chordDur, "sawtooth", 0.22);
    playTone(G5, chordStart, chordDur, "sawtooth", 0.22);
    playTone(C6, chordStart, chordDur, "sawtooth", 0.20);

    // Refuerzo de graves (subarm√≥nicos sencillos)
    playTone(261.63, chordStart, 0.5, "square", 0.08); // C4
  } catch(e) {
    console.warn("Fanfarria no disponible:", e);
  }
}

/* ===== INICIAR ===== */
iniciar.onclick = async function(){
  if(girando) return;
  if(lista.length < 3) return alert("Necesitas m√≠nimo 3 participantes");

  girando = true;

  // Tres giros
  for(let i=0; i<3; i++){
    // Elegimos √≠ndice sobre la lista ACTUAL
    const index = Math.floor(Math.random() * lista.length);

    // Primero giramos; al detenerse se sabr√° el seleccionado real
    await girar(index);

    const elegido = lista[index];

    if(i < 2){
      // 1¬∫ y 2¬∫ giro: eliminado
      resultado.innerText = elegido.nombre + " - FUERA ‚ùå";
      // Anuncia nombre y n√∫mero (en d√≠gitos para dicci√≥n clara)
      hablar(`${elegido.nombre}, n√∫mero ${numeroEnDigitos(elegido.numero)}. Fuera.`, 0.95, 1.05);

      // Mantener 3s el nombre mostrado
      await sleep(3000);

      // Desvanecer el segmento seleccionado ANTES de eliminar
      await animarDesvanecer(index, 600);

      // Ahora s√≠, eliminar de la lista y de opacidades
      lista.splice(index, 1);
      opacidades.splice(index, 1);
      guardar();

      // Reajusta opacidades (reinicia a 1 para los restantes)
      opacidades = lista.map(() => 1);

      // Redibuja la ruleta ya ‚Äúrecalculada‚Äù
      redibujar();

      // Peque√±a pausa est√©tica opcional
      await sleep(150);

    }else{
      // 3er giro: GANADOR (sin desvanecer)
      resultado.innerText = `üèÜ ${elegido.nombre} (N¬∫ ${elegido.numero}) GANADOR üéâ`;
      // Anuncia nombre y n√∫mero (en d√≠gitos para dicci√≥n clara)
      hablar(`¬°Tenemos ganador! ${elegido.nombre}, n√∫mero ${numeroEnDigitos(elegido.numero)}.`, 0.85, 1.15);

      pantallaGanador.style.display = "flex";
      pantallaGanador.innerHTML = `üèÜ<br>${elegido.nombre}<br>N¬∫ ${elegido.numero}`;

      // Confeti + Fanfarria al ganador
      confetiGanador();
      playFanfare();

      setTimeout(()=>{
        pantallaGanador.style.display="none";
      }, 6000);
    }
  }

  girando = false;
};
</script>

</body>
</html>
